
// Grid Generator and Structure Script
// by Kyle Furey

using UnityEngine;

/// <summary>
/// Generates a mathematical grid using customizable variables.
/// </summary>
public class GridGenerator : MonoBehaviour
{
    [Header("Generates a mathematical grid using customizable variables.")]


    [Header("\nSETTINGS")]

    [Header("The 1 x 1 cube prefab used to generate the grid lines:")]
    public GameObject cubePrefab = null;

    [Header("Optional materials to represent the X, Y, and Z axes:")]
    public Material xAxisMaterial = null;
    public Material yAxisMaterial = null;
    public Material zAxisMaterial = null;

    [Header("Whether to color the entire grid based on the axis:")]
    public bool colorWholeGrid = false;

    [Header("The axis to generate the grid on (first is X, second is Y):")]
    public GridAxis generatedAxis = GridAxis.XZ;

    [Header("Whether to generate from the generator's position in just positive directions:")]
    public bool generatePositive = false;

    [Header("Grid square count:")]
    public Vector2Int count = new Vector2Int(10, 10);

    [Header("Whether to automatically include zero as its own column and row in the grid:")]
    public bool includeZero = true;

    [Header("Grid square size (scale applied to the cube prefab):")]
    public Vector2 size = new Vector2(1, 1);

    [Header("The thickness of each line (scale applied to the cube prefab):")]
    public float lineThickness = 0.05f;


    [Header("\nTESTING")]

    [Header("Whether to automatically generate a grid when the game starts:")]
    [SerializeField] private bool autoGenerate = false;

    [Header("Whether to enable live testing for grid generation:")]
    [SerializeField] private bool liveTesting = false;

    [Header("Test generation button:")]
    [SerializeField] private bool test = false;

    /// <summary>
    /// The current grid gameobject generated by this generator
    /// </summary>
    [HideInInspector] public GameObject generatedGrid = null;

    /// <summary>
    /// Grid axis enum
    /// </summary>
    public enum GridAxis { XZ, XY, ZY };


    // TESTING

    /// <summary>
    /// Generate on awake
    /// </summary>
    private void Awake()
    {
        if (autoGenerate)
        {
            GenerateGrid();
        }
    }

    /// <summary>
    /// Generate in editor
    /// </summary>
    private void OnValidate()
    {
        if (test)
        {
            test = false;

            Invoke("GenerateEditor", 0);
        }

        if (liveTesting)
        {
            Invoke("GenerateEditor", 0);
        }
    }

    /// <summary>
    /// Destroy the grid object and regenerate it
    /// </summary>
    private void GenerateEditor()
    {
        if (generatedGrid != null)
        {
            DestroyImmediate(generatedGrid);
        }

        GenerateGrid();
    }


    // GRID FUNCTIONS

    /// <summary>
    /// Logic for generating a grid
    /// </summary>
    /// <returns></returns>
    private GameObject Generate()
    {
        GameObject gridParent = new GameObject("Generated Grid");

        gridParent.transform.parent = transform;

        gridParent.transform.localPosition = Vector3.zero;
        gridParent.transform.localEulerAngles = Vector3.zero;
        gridParent.transform.localScale = Vector3.one;

        if (count.x < 0)
        {
            count.x *= -1;
        }

        if (count.y < 0)
        {
            count.y *= -1;
        }

        if (lineThickness < 0)
        {
            lineThickness *= -1;
        }

        int countX = includeZero ? count.x + 1 : count.x;
        int countY = includeZero ? count.y + 1 : count.y;

        for (int x = 0; x < countY + 1; x++)
        {
            GameObject line = Instantiate(cubePrefab);

            line.transform.parent = gridParent.transform;

            line.transform.localPosition = Vector3.zero;
            line.transform.localEulerAngles = Vector3.zero;
            line.transform.localScale = Vector3.one;

            if (line.GetComponent<Renderer>() == null)
            {
                Debug.LogError("Grid Generation Error: Cube Prefab must have a Renderer and a Mesh to visualize the grid!");
            }
            else if (colorWholeGrid)
            {
                line.GetComponent<Renderer>().material = selectref((int)generatedAxis, xAxisMaterial, xAxisMaterial, zAxisMaterial) == null ? line.GetComponent<Renderer>().material : selectref((int)generatedAxis, xAxisMaterial, yAxisMaterial, zAxisMaterial);
            }
            else
            {
                line.GetComponent<Renderer>().material = selectref((int)generatedAxis, xAxisMaterial, xAxisMaterial, zAxisMaterial) == null ? line.GetComponent<Renderer>().material : selectref((int)generatedAxis, xAxisMaterial, xAxisMaterial, zAxisMaterial);
            }

            line.transform.localPosition += x * size.y * selectref((int)generatedAxis, new Vector3(0, 0, 1), new Vector3(0, 1, 0), new Vector3(0, 1, 0));

            if (generatePositive)
            {
                line.transform.localPosition += countX * size.x * selectref((int)generatedAxis, new Vector3(1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)) / 2;
            }
            else
            {
                line.transform.localPosition -= countY * size.y * selectref((int)generatedAxis, new Vector3(0, 0, 1), new Vector3(0, 1, 0), new Vector3(0, 1, 0)) / 2;
            }

            line.transform.localScale = selectref((int)generatedAxis, new Vector3(countX * size.x, lineThickness, lineThickness), new Vector3(countX * size.x, lineThickness, lineThickness), new Vector3(lineThickness, lineThickness, countX * size.x));

            line.transform.localScale += selectref((int)generatedAxis, new Vector3(lineThickness, 0, 0), new Vector3(lineThickness, 0, 0), new Vector3(0, 0, lineThickness));
        }

        for (int y = 0; y < countX + 1; y++)
        {
            GameObject line = Instantiate(cubePrefab);

            line.transform.parent = gridParent.transform;

            line.transform.localPosition = Vector3.zero;
            line.transform.localEulerAngles = Vector3.zero;
            line.transform.localScale = Vector3.one;

            if (line.GetComponent<Renderer>() == null)
            {
                Debug.LogError("Grid Generation Error: Cube Prefab must have a Renderer and a Mesh to visualize the grid!");
            }
            else if (colorWholeGrid)
            {
                line.GetComponent<Renderer>().material = selectref((int)generatedAxis, xAxisMaterial, xAxisMaterial, zAxisMaterial) == null ? line.GetComponent<Renderer>().material : selectref((int)generatedAxis, xAxisMaterial, yAxisMaterial, zAxisMaterial);
            }
            else
            {
                line.GetComponent<Renderer>().material = selectref((int)generatedAxis, zAxisMaterial, yAxisMaterial, yAxisMaterial) == null ? line.GetComponent<Renderer>().material : selectref((int)generatedAxis, zAxisMaterial, yAxisMaterial, yAxisMaterial);
            }

            line.transform.localPosition += y * size.x * selectref((int)generatedAxis, new Vector3(1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1));

            if (generatePositive)
            {
                line.transform.localPosition += countY * size.y * selectref((int)generatedAxis, new Vector3(0, 0, 1), new Vector3(0, 1, 0), new Vector3(0, 1, 0)) / 2;
            }
            else
            {
                line.transform.localPosition -= countX * size.x * selectref((int)generatedAxis, new Vector3(1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)) / 2;
            }

            line.transform.localScale = selectref((int)generatedAxis, new Vector3(lineThickness, lineThickness, countY * size.y), new Vector3(lineThickness, countY * size.y, lineThickness), new Vector3(lineThickness, countY * size.y, lineThickness));

            line.transform.localScale += selectref((int)generatedAxis, new Vector3(0, 0, lineThickness), new Vector3(0, lineThickness, 0), new Vector3(0, lineThickness, 0));
        }

        return gridParent;
    }

    /// <summary>
    /// Generate a grid with the given variables
    /// </summary>
    /// <returns></returns>
    public GridGenerator GenerateGrid()
    {
        if (generatedGrid != null)
        {
            Destroy(generatedGrid);
        }

        if (cubePrefab == null)
        {
            return this;
        }

        generatedGrid = Generate();

        return this;
    }

    /// <summary>
    /// Detach the current grid from the generated grid
    /// </summary>
    /// <returns></returns>
    public GameObject DetachGrid()
    {
        GameObject grid = generatedGrid;

        if (grid != null)
        {
            generatedGrid = null;

            grid.transform.parent = null;
        }

        return grid;
    }

    /// <summary>
    /// Using the current settings, return the corresponding local position of the given world position relative to the grid.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector3 GetLocalPosition(Vector3 position)
    {
        position -= Quaternion.Euler(-transform.eulerAngles.x, -transform.eulerAngles.y, -transform.eulerAngles.z) * transform.position;

        position = new Vector3(position.x / transform.lossyScale.x, position.y / transform.lossyScale.y, position.z / transform.lossyScale.z);

        position.x /= selectref((int)generatedAxis, size.x, size.x, 1);
        position.y /= selectref((int)generatedAxis, 1, size.y, size.y);
        position.z /= selectref((int)generatedAxis, size.y, 1, size.x);

        return position;
    }

    /// <summary>
    /// Using the current settings, return the corresponding world position of the given local position relative to the grid.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector3 GetWorldPosition(Vector3 position)
    {
        position.x *= selectref((int)generatedAxis, size.x, size.x, 1);
        position.y *= selectref((int)generatedAxis, 1, size.y, size.y);
        position.z *= selectref((int)generatedAxis, size.y, 1, size.x);

        position = new Vector3(position.x * transform.lossyScale.x, position.y * transform.lossyScale.y, position.z * transform.lossyScale.z);

        position = transform.rotation * position;

        position += transform.position;

        return position;
    }

    /// <summary>
    /// Using the current settings, get the corresponding grid space of the given world position.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector2Int GetGridSpace(Vector3 position)
    {
        position = GetLocalPosition(position);

        if (!generatePositive)
        {
            if (includeZero)
            {
                if (count.x % 2 == 0)
                {
                    switch (generatedAxis)
                    {
                        case GridAxis.XZ:

                            position.x += size.x * 0.5f;

                            break;

                        case GridAxis.XY:

                            position.x += size.x * 0.5f;

                            break;

                        case GridAxis.ZY:

                            position.z += size.x * 0.5f;

                            break;
                    }
                }

                if (count.y % 2 == 0)
                {
                    switch (generatedAxis)
                    {
                        case GridAxis.XZ:

                            position.z += size.y * 0.5f;

                            break;

                        case GridAxis.XY:

                            position.y += size.y * 0.5f;

                            break;

                        case GridAxis.ZY:

                            position.y += size.y * 0.5f;

                            break;
                    }
                }
            }
            else
            {
                if (count.x % 2 == 1)
                {
                    switch (generatedAxis)
                    {
                        case GridAxis.XZ:

                            position.x += size.x * 0.5f;

                            break;

                        case GridAxis.XY:

                            position.x += size.x * 0.5f;

                            break;

                        case GridAxis.ZY:

                            position.z += size.x * 0.5f;

                            break;
                    }
                }

                if (count.y % 2 == 1)
                {
                    switch (generatedAxis)
                    {
                        case GridAxis.XZ:

                            position.z += size.y * 0.5f;

                            break;

                        case GridAxis.XY:

                            position.y += size.y * 0.5f;

                            break;

                        case GridAxis.ZY:

                            position.y += size.y * 0.5f;

                            break;
                    }
                }
            }
        }

        return new Vector2Int(Mathf.FloorToInt(selectref((int)generatedAxis, position.x, position.x, position.z)), Mathf.FloorToInt(selectref((int)generatedAxis, position.z, position.y, position.y)));
    }

    /// <summary>
    /// Using the current settings, get the corresponding grid space of the given world position and return if that position is inside the grid.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <param name="inGrid"></param>
    /// <returns></returns>
    public Vector2Int GetGridSpace(Vector3 position, out bool inGrid)
    {
        Vector2Int gridPosition = GetGridSpace(position);

        inGrid = GridSpaceInGrid(gridPosition);

        return gridPosition;
    }

    /// <summary>
    /// Using the current settings, check if the given position is inside the grid.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public bool InGrid(Vector3 position)
    {
        return GridSpaceInGrid(GetGridSpace(position));
    }

    /// <summary>
    /// Using the current settings, check if the given position is inside the grid and return the grid position of the given position.
    /// Does not require an actual grid to be generated; uses the settings of the grid generator.
    /// </summary>
    /// <param name="position"></param>
    /// <param name="gridPosition"></param>
    /// <returns></returns>
    public bool InGrid(Vector3 position, out Vector2Int gridPosition)
    {
        gridPosition = GetGridSpace(position);

        return GridSpaceInGrid(gridPosition);
    }

    /// <summary>
    /// Calculate whether the given grid position is inside the grid/
    /// </summary>
    /// <param name="gridPosition"></param>
    /// <returns></returns>
    public bool GridSpaceInGrid(Vector2Int gridPosition)
    {
        return generatePositive ?
        (gridPosition.x >= 0 &&
        gridPosition.x <= size.x * (includeZero ? count.x : count.x - 1) &&
        gridPosition.y >= 0 &&
        gridPosition.y <= size.y * (includeZero ? count.y : count.y - 1))
        :
        (gridPosition.x >= size.x * (includeZero ? count.x : count.x - 1) / -2 &&
        gridPosition.x <= size.x * (includeZero ? count.x : count.x - 1) / 2 &&
        gridPosition.y >= size.y * (includeZero ? count.y : count.y - 1) / -2 &&
        gridPosition.y <= size.y * (includeZero ? count.y : count.y - 1) / 2);
    }

    /// <summary>
    /// Select from an integer and return the chosen data
    /// </summary>
    /// <typeparam name="DataType"></typeparam>
    /// <param name="n"></param>
    /// <param name="nData"></param>
    /// <returns></returns>
    private static ref DataType selectref<DataType>(int n, params DataType[] nData)
    {
        return ref nData[n];
    }
}

/// <summary>
/// A collection of variables representing an infinite mathematical grid.
/// </summary>
public struct Grid
{
    // VARIABLES

    /// <summary>
    /// The origin of this grid
    /// </summary>
    public Vector3 origin;

    /// <summary>
    /// The rotation of this grid
    /// </summary>
    public Quaternion rotation;

    /// <summary>
    /// The scale of this grid
    /// </summary>
    public Vector3 scale;

    /// <summary>
    /// Grid square size
    /// </summary>
    public Vector2 size;

    /// <summary>
    /// The axis this grid is on (first is X, second is Y)
    /// </summary>
    public GridAxis axis;

    /// <summary>
    /// Grid axis enum
    /// </summary>
    public enum GridAxis { XZ, XY, ZY };


    // CONSTRUCTORS

    /// <summary>
    /// Default constructor
    /// </summary>
    public Grid(object empty = null)
    {
        origin = Vector3.zero;
        rotation = Quaternion.identity;
        scale = Vector3.one;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    public Grid(Vector3 origin)
    {
        this.origin = origin;
        rotation = Quaternion.identity;
        scale = Vector3.one;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="rotation"></param>
    public Grid(Vector3 origin, Quaternion rotation)
    {
        this.origin = origin;
        this.rotation = rotation;
        scale = Vector3.one;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="rotation"></param>
    /// <param name="scale"></param>
    public Grid(Vector3 origin, Quaternion rotation, Vector3 scale)
    {
        this.origin = origin;
        this.rotation = rotation;
        this.scale = scale;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="rotation"></param>
    /// <param name="scale"></param>
    /// <param name="size"></param>
    public Grid(Vector3 origin, Quaternion rotation, Vector3 scale, Vector2 size)
    {
        this.origin = origin;
        this.rotation = rotation;
        this.scale = scale;
        this.size = size;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="rotation"></param>
    /// <param name="scale"></param>
    /// <param name="size"></param>
    /// <param name="axis"></param>
    public Grid(Vector3 origin, Quaternion rotation, Vector3 scale, Vector2 size, GridAxis axis)
    {
        this.origin = origin;
        this.rotation = rotation;
        this.scale = scale;
        this.size = size;
        this.axis = axis;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="eulerRotation"></param>
    public Grid(Vector3 origin, Vector3 eulerRotation)
    {
        this.origin = origin;
        rotation = Quaternion.Euler(eulerRotation);
        scale = Vector3.one;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="eulerRotation"></param>
    /// <param name="scale"></param>
    public Grid(Vector3 origin, Vector3 eulerRotation, Vector3 scale)
    {
        this.origin = origin;
        rotation = Quaternion.Euler(eulerRotation);
        this.scale = scale;
        size = Vector2.one;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="eulerRotation"></param>
    /// <param name="scale"></param>
    /// <param name="size"></param>
    public Grid(Vector3 origin, Vector3 eulerRotation, Vector3 scale, Vector2 size)
    {
        this.origin = origin;
        rotation = Quaternion.Euler(eulerRotation);
        this.scale = scale;
        this.size = size;
        axis = GridAxis.XZ;
    }

    /// <summary>
    /// Grid constructor
    /// </summary>
    /// <param name="origin"></param>
    /// <param name="eulerRotation"></param>
    /// <param name="scale"></param>
    /// <param name="size"></param>
    /// <param name="axis"></param>
    public Grid(Vector3 origin, Vector3 eulerRotation, Vector3 scale, Vector2 size, GridAxis axis)
    {
        this.origin = origin;
        rotation = Quaternion.Euler(eulerRotation);
        this.scale = scale;
        this.size = size;
        this.axis = axis;
    }

    /// <summary>
    /// Copy constructor
    /// </summary>
    /// <param name="grid"></param>
    public Grid(Grid grid)
    {
        origin = grid.origin;
        rotation = grid.rotation;
        scale = grid.scale;
        size = grid.size;
        axis = grid.axis;
    }


    // FUNCTIONS

    /// <summary>
    /// Using the current settings, return the corresponding local position of the given world position relative to the grid
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector3 GetLocalPosition(Vector3 position)
    {
        position -= Quaternion.Euler(-rotation.eulerAngles.x, -rotation.eulerAngles.y, -rotation.eulerAngles.z) * origin;

        position = new Vector3(position.x / scale.x, position.y / scale.y, position.z / scale.z);

        position.x /= selectref((int)axis, size.x, size.x, 1);
        position.y /= selectref((int)axis, 1, size.y, size.y);
        position.z /= selectref((int)axis, size.y, 1, size.x);

        return position;
    }

    /// <summary>
    /// Using the current settings, return the corresponding world position of the given local position relative to the grid
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector3 GetWorldPosition(Vector3 position)
    {
        position.x *= selectref((int)axis, size.x, size.x, 1);
        position.y *= selectref((int)axis, 1, size.y, size.y);
        position.z *= selectref((int)axis, size.y, 1, size.x);

        position = new Vector3(position.x * scale.x, position.y * scale.y, position.z * scale.z);

        position = rotation * position;

        position += origin;

        return position;
    }

    /// <summary>
    /// Using the current settings, get the corresponding grid space of the given world position.
    /// </summary>
    /// <param name="position"></param>
    /// <returns></returns>
    public Vector2Int GetGridSpace(Vector3 position)
    {
        position = GetLocalPosition(position);

        return new Vector2Int(Mathf.FloorToInt(selectref((int)axis, position.x, position.x, position.z)), Mathf.FloorToInt(selectref((int)axis, position.z, position.y, position.y)));
    }

    /// <summary>
    /// Select from an integer and return the chosen data
    /// </summary>
    /// <typeparam name="DataType"></typeparam>
    /// <param name="n"></param>
    /// <param name="nData"></param>
    /// <returns></returns>
    private static ref DataType selectref<DataType>(int n, params DataType[] nData)
    {
        return ref nData[n];
    }
}
